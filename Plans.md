### Phase 0: 公共内核构建（必须协同完成）
**目标**：确立“共同语言”，防止后续无法联调。

**参与者**：教师端开发者 & 学生端开发者

| 任务 ID | 任务名称 | 架构/技术点 | 说明 |
| :--- | :--- | :--- | :--- |
| **0.1** | **数据模型定义 (Common Models)** | POJO | 统一定义 `Question`, `Exam`, `Student`, `Answer` 类。**这是所有功能的基础。** |
| **0.2** | **通信协议设计 (Protocol)** | `util` 包 | 1. 确定 JSON 顶层结构（Type, Payload）。<br>2. 定义 `MessageType` 枚举（LOGIN, EXAM, SUBMIT...）。 |
| **0.3** | **JSON 工具类封装** | Jackson/Gson | 编写统一的 `JsonUtil`，确保两端序列化/反序列化行为一致。 |
| **0.4** | **Netty 编解码器** | Netty | 共同编写 `FrameDecoder` (处理粘包) 和 `MessageCodec`。这段代码两端是通用的，写好一份复制即可。 |

---

### Phase 1: 基础设施搭建
**前置任务**：Phase 0

#### 👨‍🏫 教师端开发者 (Server & DB)

| 任务 ID | 任务名称 | 架构/技术点 | 说明 |
| :--- | :--- | :--- | :--- |
| **T1.1** | **数据库初始化** | SQLite | 设计 `exam.db`，建表（Exam, Question, Student）。 |
| **T1.2** | **DAO 层实现** | **[DAO 模式]** | 封装 JDBC 操作。实现 `QuestionDAO`, `ExamDAO`。**要求**：Service 层通过 DAO 接口调用，不直接写 SQL。 |
| **T1.3** | **Netty Server 启动类** | Netty ServerBootstrap | 编写 Server 启动代码，绑定端口，配置 Pipeline（引用任务 0.4 的编解码器）。 |
| **T1.4** | **主界面框架** | JavaFX | 搭建主界面（菜单栏、TabPane），确立 Controller 与 Service 的依赖注入关系。 |

#### 👨‍🎓 学生端开发者 (Client & UI)

| 任务 ID | 任务名称 | 架构/技术点 | 说明 |
| :--- | :--- | :--- | :--- |
| **S1.1** | **登录界面** | JavaFX | 制作输入 IP、端口、姓名的界面。 |
| **S1.2** | **Netty Client 启动类** | Netty Bootstrap | 编写 Client 连接代码。实现 `connect()` 方法和重连逻辑的基础框架。 |
| **S1.3** | **本地数据管理** | IO / Properties | 实现 `ConfigService`，用于保存上次登录的 IP 和用户名，避免重复输入。 |

---

### Phase 2: 连接与握手 (First Contact)
**前置任务**：T1.3, S1.2, 0.2

这一阶段结束时，学生应该能连接上老师，老师列表能显示学生。

#### 👨‍🏫 教师端

| 任务 ID | 任务名称 | 前置任务 | 说明 |
| :--- | :--- | :--- | :--- |
| **T2.1** | **连接管理器 (ClientHandler)** | Netty Handler | 处理新连接。在内存中维护 `Map<ChannelId, StudentInfo>`。 |
| **T2.2** | **处理登录请求** | Service 层 | 解析 `LOGIN_REQ`，校验是否重复登录，广播 `LOGIN_RESP`。 |
| **T2.3** | **在线学生列表 UI** | JavaFX ObservableList | 将网络层收到的学生信息实时更新到界面的 `TableView` 中（注意 `Platform.runLater`）。 |

#### 👨‍🎓 学生端

| 任务 ID | 任务名称 | 前置任务 | 说明 |
| :--- | :--- | :--- | :--- |
| **S2.1** | **发送登录包** | Netty Handler | 连接成功后，立即组装 `LOGIN_REQ` JSON 并发送。 |
| **S2.2** | **处理登录响应** | Service 层 | 接收 `LOGIN_RESP`。成功则跳转至“等待大厅”界面，失败则弹出 Alert。 |
| **S2.3** | **心跳机制** | Netty IdleState | 实现 `userEventTriggered`，空闲时发送 `HEARTBEAT` 包。 |

---

### Phase 3: 考试业务核心 (The Exam)
**前置任务**：Phase 2 联调通过, T1.2 (DAO)

#### 👨‍🏫 教师端

| 任务 ID | 任务名称 | 前置任务 | 说明 |
| :--- | :--- | :--- | :--- |
| **T3.1** | **试卷管理界面** | JavaFX + DAO | 实现题目的增删改查 UI，能够组装一份 `Exam` 对象。 |
| **T3.2** | **试卷分发逻辑** | Network Service | 点击“开始考试”按钮 -> 将 `Exam` 对象转 JSON -> 遍历在线学生列表 -> 广播发送。 |
| **T3.3** | **监控大屏** | UI | 简单的仪表盘，显示“考试中”状态，准备接收答案。 |

#### 👨‍🎓 学生端

| 任务 ID | 任务名称 | 前置任务 | 说明 |
| :--- | :--- | :--- | :--- |
| **S3.1** | **动态答题卡 UI** | **[动态 UI 生成]** | 接收 `EXAM_START` 包。根据题目类型（选择/填空），在 VBox 中动态 `new RadioButton()` 或 `new TextArea()`。 |
| **S3.2** | **本地答案缓存** | Service 层 | 监听控件变化，实时更新内存中的 `AnswerMap`。**防止误触提交。** |
| **S3.3** | **提交逻辑** | Network Service | 点击提交或时间到 -> 组装 `ANSWER_SUBMIT` JSON -> 发送。 |

---

### Phase 4: 收尾与高级功能
**前置任务**：Phase 3

#### 👨‍🏫 教师端

| 任务 ID | 任务名称 | 前置任务 | 说明 |
| :--- | :--- | :--- | :--- |
| **T4.1** | **接收答案与落库** | **[DAO + 事务]** | 收到 `ANSWER_SUBMIT` -> 写入数据库。 |
| **T4.2** | **自动阅卷服务** | Service 层 | 实现核心阅卷算法，对比答案，计算分数，更新数据库。 |
| **T4.3** | **成绩导出/展示** | UI | 从数据库读取最终成绩，展示在 TableView，支持导出 CSV。 |

#### 👨‍🎓 学生端

| 任务 ID | 任务名称 | 前置任务 | 说明 |
| :--- | :--- | :--- | :--- |
| **S4.1** | **断线重连/灾备** | File IO | **关键功能**。每答一题将答案序列化写入本地临时文件。程序崩溃重启后，读取文件恢复作答状态。 |
| **S4.2** | **UI 美化** | CSS | 由于学生端逻辑较轻，建议学生端开发者承担更多 UI 美化工作（CSS 样式）。 |

---

### 分工总结与建议

1.  **架构与模式**：
    *   **教师端**必须严格遵守 `Controller -> Service -> DAO -> DB` 的分层，否则后期逻辑复杂时代码会崩溃。
    *   **网络层**建议抽取一个独立的 Module（或 Package），两端代码尽量保持一致。

2.  **工作量平衡调整**：
    *   你会发现 **T3.1 (试卷管理)** 和 **T4.2 (阅卷)** 逻辑很复杂。
    *   建议：**S3.1 (动态 UI 生成)** 也是难点。如果学生端开发者进度较快，可以让他负责编写 **“模拟数据生成器”**，帮助教师端在没有真实连接时也能测试阅卷功能。

3.  **联调节点 (Milestones)**：
    *   **里程碑 1**：学生能登录，老师能看到（验证网络层）。
    *   **里程碑 2**：老师点开始，学生界面刷出题目（验证下行通信）。
    *   **里程碑 3**：学生点提交，老师后台打印出答案 JSON（验证上行通信）。
    *   **里程碑 4**：阅卷完成，数据入库（验证业务闭环）。
